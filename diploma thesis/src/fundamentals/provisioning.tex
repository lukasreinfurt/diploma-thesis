\section{Provisioning}
\label{fundamentals:provisioning}

This section provides an overview of provisioning in general and describes some of the provisioning solution available today.
It focuses in particular on TOSCA and Open TOSCA, since those are used in the prototypical implementation later on.

\subsection{Overview}

Setting up a complex distributed system with many different components scattered across multiple environments is a time-consuming task if done by hand.
For this reason, many provisioning solutions have been created over the years to automate this process.
They differ in some areas, which we will discuss later, but their core functionality is in basically identical: They prepare all necessary resources for a certain task.
Let's state this core functionality a little more precise with the following definition: Provisioning is, "in telecommunications, the setting in place and configuring of the hardware and software required to activate a telecommunications service for a customer; in many cases the hardware and software may already be in place and provisioning entails only configuration tasks"~\autocite{def:provisioning}.
Since we are working in a cloud environment, we won't have to deal with hardware directly, but rather with \nom{virtual machines}{VMs}.
So for us, provisioning means the creation and deletion of VMs in a cloud environment, as well as the installation, configuration, monitoring, running and stopping of software on these VMs~\autocite{towardsprovisioning}.

The are many benefits to using an automated provisioning solution in stead of doing things manually.
The manual approach is limited by how much work a single person can do at any time, whereas an automatic approach is able to do much more work, in less time, and potentially in parallel.
This makes it possible to manage huge infrastructures with very little resources, which can save money compared to a manual approach.
Since every step that needs to be done to provision a system has to be written down, a detailed description of the whole provisioning process is created.
This makes the whole process reproducible and less error prone, since the human factor is taken out.
Parts of such a description can also be shared in a business or even between businesses, which makes the process of creating such a description potentially much more efficient.

The general process of working with provisioning software is very similar with all the different solutions.
It can be described as a two step process.
In step one, a description of the whole provisioning process has to be created using the tools provided by the particular solution.
In general this involves creating a textual description in a certain format that is understood by the provisioning software that is to be used.
In this description, we tell the software what virtual resources we need, what software should be installed on them and how everything should be configured.
In step two, we pass this description to the provisioning software, which interprets and executes it.

Many different provisioning solutions exist today.
Some cloud providers offer provisioning solutions that are particularly tailored to their cloud offerings, for example AWS CloudFormation\footnote{\url{http://aws.amazon.com/cloudformation}}, which can only be used to provision resources in the Amazon cloud.
Then, there are more generally usable provisioning solutions that are not bound to any particular cloud provider.
A few popular examples include Ansible\footnote{\url{http://www.ansible.com}}, Chef\footnote{\url{http://www.getchef.com/chef}}, Puppet\footnote{\url{http://puppetlabs.com/}}, and TOSCA, which we will discuss in detail later.

All these solutions differ in some form or another.
A full feature comparison of different solutions is out of scope for this diploma thesis, but what follows is a short overview of some of the differences.
As already mentioned, AWS CloudFront is bound to Amazons cloud platform, while the other solutions are not.
Chef and Puppet both use a client server architecture, where each node that should be configured by them has to run a client program to communicate with a server node, whereas Ansible executes its command over SSH and therefor doesn't require additional software on the nodes that are configured.
The solutions also differ in modularity and flexibility. While Ansible, Chef, Puppet and TOSCA are highly flexible and can be used in a fine grained modular fashion, this also makes them more complex to use, for example compared to AWS CloudFront.

\subsection{TOSCA}

\nom{Topology and Orchestration Specification for Cloud Applications}{TOSCA} is a standard that is currently being worked on by the \nom{Organization for the Advancement of Structured Information Standards}{OASIS}\footnote{\url{https://www.oasis-open.org/}}.
Its development is also supported by various industry partners, which include IBM, Cisco, SAP, HP and others.
It's aim is to provide a language that can describe service components and their relations in a cloud environment independent fashion~\autocite{tosca:spec}.

TOSCA defines an XML syntax, which describes services and their relations in a so called service templates.
\autoref{image:tosca:servicetemplate} shows that a service template can be made of up of four distinct parts: Topology templates, orchestration plans, reusable entities, and artifact templates.

\begin{figure}[!htbp]
	\centering
	\includegraphics[resolution=600]{fundamentals/assets/service_template}
	\caption{TOSCA service template structure~\autocite[based on][]{tosca:spec}.}
	\label{image:tosca:servicetemplate}
\end{figure}

Topology templates, as seen on the left side of \autoref{image:tosca:servicetemplate}, model the structure of a service as a directed graph.
The vertices of the graph represent nodes, which are occurrences of a specific component, for example, an application server or a database.
These nodes are defined by node types, or by other service templates.
Node types are reusable entities,  as shown in the top center of \autoref{image:tosca:servicetemplate}.
They define the properties of a component, as well as operations to manipulate a component, so called interfaces.
Additionally, node types can be annotated with requirements and capabilities.
These, in turn, are defined by requirement and capability types, which also belong to the group of reusable entities.
This allows for requirement and capability matching between different components.
The edges of the graph represent connections between nodes, which are defined by relationship templates that specify the properties of the relation.
An example for such a connection would be a node A, representing a web service, which is deployed on node B, an application server.
Relationship types are also used to connect requirements and capabilities.

Orchestration plans, shown on the right of \autoref{image:tosca:servicetemplate}, are used to manage the service that is defined by the service template. TOSCA distinguishes between three types of plans: Build plans, termination plans, and modification plans.
Build plans describe how instances of a service are created.
Termination plans describe how such a service is removed.
Modification plans manage a service during its runtime.
These plans consist of one or more tasks, i.e., an operation on a node (via an interface) or an external service call, and the order in which these tasks should be performed.
They can be written in \nom{Business Process Model and Notation}{BPMN} or \nom{Business Process Execution Language}{BPEL}, which are already existing languages to describe process models.

The bottom center of \autoref{image:tosca:servicetemplate} shows artifact templates, which represent artifacts.
Artifacts are things that can be executed directly (e.g.: scripts, archives) or indirectly (e.g.: URL, ports).
TOSCA further distinguishes between two types of artifacts, namely deployment and implementation artifacts.
Deployment artifacts materialize instances of a node and are used by a build plan to create a service.
An example for this is an \nom{Amazon Machine Image}{AMI}, which creates an Apache server once deployed in a VM.
Implementation artifacts represent the interfaces of components.
Here, an example would be a node that has an interface for starting the particular component described by the node.
This interfaces could be implemented by an implementation artifact like a \textit{.jar} file.

One or more TOSCA service templates are packaged, together with some meta data, into a \nom{Cloud Service Archive}{CSAR}, which is essentially a zip file that contains all files necessary to create and manage a service.
CSAR files can then be executed in a TOSCA runtime environment, also called TOSCA container, to create the service described within.

\subsection{OpenTOSCA}

OpenTOSCA is a browser based open-source implementation of a TOSCA container, created at the IAAS at University Stuttgart, which supports the execution of TOSCA CSAR archives.
\autoref{image:tosca:opentosca} shows the architecture of OpenTOSCA.
Its functionality is realized in three main components, which are the Controller, the Implementation Artifact Engine, and the Plan Engine.
After a CSAR is uploaded to OpenTOSCA it can be deployed in three steps.
In the first step, the CSAR file is unpacked and its content is stored for further use.
The TOSCA XML files are then loaded and processed by the Controller.
The Controller in turn calls the Implementation Artifact Engine and the Plan Engine.
The Implementation Artifact Engine knows how to deploy and store the provided implementation artifacts via plugins.
Plans are then run by the Plan Engine, which also uses plugins to support different plan formats.
OpenTOSCA also offers two APIs, the Container API and the Plan Portability API.
The Container API can be used to access the functionality provided by the container from outside and to provide additional interfaces to the container, like the already existing admin UI, self-service portal, or modeling tool.
The Plan Portability API is used by plans to access topology and instance information~\autocite{opentosca}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[resolution=600]{fundamentals/assets/opentosca}
	\caption{OpenTOSCA architecture~\autocite[based on][]{opentosca}.}
	\label{image:tosca:opentosca}
\end{figure}
