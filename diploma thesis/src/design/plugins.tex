\section{Plugin Types}
\label{design:plugins}

We can already tell from the requirements that we must at least support two different plugin types, one for different cloud providers and one for different provisioning engines.
The former are required because we may want to provision into different cloud environments.
The latter are required because we might want to use different provisioning engines to do so.

The cloud provider plugins will be responsible for creating and removing resources in cloud environments and making them available for the user to configure and use.
This could be bare bone VMs (like AWS EC2 instances), or PaaS environments (like AWS Beanstalk).
We don't even have to constrain these plugins to cloud resources and can make them more abstract, as long as we can run the plugin and get an IP address to a computer resource that we can use.
For example, we could also provide a plugin that starts and stops VMs on our local machine, which could be useful for quick and inexpensive local testing.
So a better name for these plugins would be \textit{infrastructure plugins}.

The same line of thinking can be used on the provisioning engine plugins.
All that we care about is that we can get some software running on a given infrastructure and that we get back an URL where we can find this software once it is up and running.
A better name for these plugins would therefore be \textit{payload plugins}.

Now that we have infrastructure plugins and payload plugins, we should be able to provision the infrastructure we need and use payload plugins to install and run any software on it.
But there is a step in between provisioning the infrastructure and installing the software that we are glancing over: We have to somehow connect to the infrastructure before we can install something.
The connection functionality could be part of either the infrastructure plugins or the payload plugins, or it could be separated into independent connection plugins.

For the sake of efficiency and extensibility it would be best to use independent connection plugins.
For example, if a user wanted to add a new connection type that should be used to install x applications in y environments, they could do so by writing one new connection plugin, instead of adding the functionality x-times to all payload plugins, or y-times to all infrastructure plugins.
This would also reduce code duplication.
Therefore, a third plugin type is necessary: The \textit{connection plugins}.

The remote bootware also has to handle the initial provisioning of the workflow middleware, which involves calling a provisioning engine to tell it to start the provisioning process.
Since this has to be done differently for all provisioning engines, it would make sense to also package this functionality into plugins that can be interchanged.
We therefore introduce a fourth plugin type: The \textit{call provisioning engine plugins}.

In \autoref{design:communication} we also introduced the notion of secondary communication channels realized by plugins.
We can generalize this into a more versatile fifth plugin type: The \textit{event plugins}.
These plugins are a bit less specific than the four other types.
They allow users to add functionality that reacts to (or creates) events inside the bootware.
How the actual event system will be implemented will be discussed in \autoref{design:internalcomm}.
With this fifth plugin type we have now covered all plugin types we will need.
We will describe each plugin type in more detail, but before we do this, we will describe the common operations that all plugin types have to implement.

\vspace*{\baselineskip}
\begingroup
	\centering
	\captionsetup{type=table}
	\renewcommand{\arraystretch}{2}
	\begin{tabu}[!htbp]{X[2,r]X[2,c]X[2,c]X[6,l]}

			\multicolumn{1}{c}{\textbf{Operation}}
		& \multicolumn{1}{c}{\textbf{Input}}
		& \multicolumn{1}{c}{\textbf{Output}}
		& \multicolumn{1}{c}{\textbf{Description}} \\

		\tabucline[0.5pt]{1-4}

			initialize
		& Configuration
		& -
		& Is called by the plugin manager when the plugin is loaded \\

			shutdown
		& -
		& -
		& Is called by the plugin manager when the plugin is unloaded \\

	\end{tabu}
	\caption{Common operations to be implemented by all plugin types}
	\label{table:all_plugins}
\endgroup

\autoref{table:all_plugins} shows the two common operations that all plugin types must implement.
The initialize operation is called by the plugin manager when it loads a plugin.
This operation can be used by plugin authors to initialize the plugin, for example by creating internal objects that will be used by other plugin operations later on.
It takes a configuration object as parameter, which is taken from the request context.
This allows the plugins to be configured from the outside if necessary.
The shutdown operation is called by the plugin manager when it unloads a plugin.
It can be useful to clean up plugin resources before the plugin is removed, for example by deleting temporary files or closing a connection.

\subsection{Infrastructure Plugins}

Infrastructure plugins are responsible for provisioning any infrastructure that the user wants to use during the bootware process.
This could be VMs on a local machine, or IaaS or PaaS environments in the cloud.
To be able to do this, an infrastructure plugin has to implement a range of functions using some API or SDK provided by the virtualization software or cloud provider.

\autoref{table:infra_plugins} shows the operations a plugins of this type should implement.
The deploy operation is responsible for deploying a resource and getting it to a state, where a connection to the resource can be established using a connection plugin.
It takes no input parameters, but relies on the configuration passed to the initialize operation to get the configuration details it needs, like login credentials.
If the deployment was successful, it returns an instance object, which contains information about the created instance, such as its IP address and login information.

The undeploy operation removes a resource that was previously deployed using the deploy operation.
In case of a local VM this could mean that it stops the running VM.
In case of a cloud resource this could mean that it completely removes the resource so that no further costs are incurred.
As input it takes an instance object created earlier by the deploy operation.

\vspace*{\baselineskip}
\begingroup
	\centering
	\captionsetup{type=table}
	\renewcommand{\arraystretch}{2}
	\begin{tabu}[!htbp]{X[2,r]X[2,c]X[2,c]X[6,l]}

			\multicolumn{1}{c}{\textbf{Operation}}
		& \multicolumn{1}{c}{\textbf{Input}}
		& \multicolumn{1}{c}{\textbf{Output}}
		& \multicolumn{1}{c}{\textbf{Description}} \\

		\tabucline[0.5pt]{1-4}

			deploy
		& -
		& Instance
		& Deploys a connection ready instance of some resource and returns an instance object \\

			undeploy
		& Instance
		& -
		& Completely removes a given instance \\

	\end{tabu}
	\caption{Interfaces to be implemented by infrastructure plugins}
	\label{table:infra_plugins}
\endgroup

\subsection{Connection Plugins}

Connection plugins are responsible for creating a communication channel to previously deployed resources that can later be used by payload plugins to execute their operations on the resource.
The connection could be made by using SSH, RDC, VPN, Telnet, or other communication mechanisms supported by the resource.
The connection plugins should be implemented generically, so that they can be used for all kinds of resources.

\autoref{table:conn_plugins} shows the operations that this type of plugin has to implement.
The connect operation establishes a connection to a specific resource.
The resource is specified by the instance object that is passed as input to the connect operation.
If the connection was established successfully, the operation returns a connection object that can be used later by payload plugins to execute operations through this connection.
The disconnect operation closes a connection that was previously established by the connect operation.
As input, it takes a connection object that was previously created by the connect operation.

\vspace*{\baselineskip}
\begingroup
	\centering
	\captionsetup{type=table}
	\renewcommand{\arraystretch}{2}
	\begin{tabu}[!htbp]{X[2,r]X[2,c]X[2,c]X[6,l]}

			\multicolumn{1}{c}{\textbf{Operation}}
		& \multicolumn{1}{c}{\textbf{Input}}
		& \multicolumn{1}{c}{\textbf{Output}}
		& \multicolumn{1}{c}{\textbf{Description}} \\

		\tabucline[0.5pt]{1-4}

			connect
		& Instance
		& Connection
		& Establishes a connection to the given instance\\

			disconnect
		& Connection
		& -
		& Disconnects a given connection \\

	\end{tabu}
	\caption{Interfaces to be implemented by connection plugins}
	\label{table:conn_plugins}
\endgroup

\subsection{Payload Plugins}

Payload plugins are responsible for installing, uninstalling, starting, and stopping software on an infrastructure instance.
This process can include the uploading of files and the execution of remote commands on an instance.

\autoref{table:payload_plugins} shows the operations that plugins of this type should implement.
The deploy operation installs a payload on an instance.
This can include uploading files from the local machine or downloading files from other machines.
To execute this operation, a connection to the instance is necessary, which is supplied as input with the connection object.
The undeploy operation removes a payload from an instance.
In most cases this will not be necessary, since the instance will be destroyed in the undeploy phase and with it all the payload data (assuming it wasn't installed in persistent storage).
This method is provided for completeness and for special cases.
The start operation starts a payload which previously was installed with the deploy operation.
If the payload was started successfully, it returns the URL to the running payload.
The stop operation stops the execution of a previously started payload.
In most cases this will not be necessary, since the payload will be removed together with the instance in the undeploy phase.
This method is provided for completeness and for special cases.

\vspace*{\baselineskip}
\begingroup
	\centering
	\captionsetup{type=table}
	\renewcommand{\arraystretch}{2}
	\begin{tabu}[!htbp]{X[2,r]X[2,c]X[2,c]X[6,l]}

			\multicolumn{1}{c}{\textbf{Operation}}
		& \multicolumn{1}{c}{\textbf{Input}}
		& \multicolumn{1}{c}{\textbf{Output}}
		& \multicolumn{1}{c}{\textbf{Description}} \\

		\tabucline[0.5pt]{1-4}

			deploy
		& Connection
		& -
		& Deploys the payload over the given connection\\

			undeploy
		& Connection
		& -
		& Undeploys the payload over the given connection\\

			start
		& Connection
		& URL
		& Starts the payload over the given connection\\

			stop
		& Connection
		& -
		& Stops the payload over the given connection\\

	\end{tabu}
	\caption{Interfaces to be implemented by payload plugins}
	\label{table:payload_plugins}
\endgroup

\subsection{Call Provisioning Engine Plugins}

Call provisioning engine plugins provide the bootware with a unified way to call provisioning engines and trigger provisioning and deprovisioning operations.
\autoref{table:provisioningengine_plugins} shows the operations that these plugins should implement.
The provision operation calls a provisioning engine and trigger the provisioning process.
It takes two inputs: An endpoint reference, which points to the provisioning engine that should be used, and a service package reference, which points to the service package that the provisioning engine should provision.
When completed successfully, the provisioning operation returns an endpoint reference to the just provisioned service.
The deprovision operation calls a provisioning engine and triggers the deprovisioning process.
It takes the same inputs as the provisioning operation, an endpoint reference to the provisioning engine and a service package reference.

\vspace*{\baselineskip}
\begingroup
	\centering
	\captionsetup{type=table}
	\renewcommand{\arraystretch}{2}
	\begin{tabu}[!htbp]{X[2,r]X[2,c]X[2,c]X[6,l]}

			\multicolumn{1}{c}{\textbf{Operation}}
		& \multicolumn{1}{c}{\textbf{Input}}
		& \multicolumn{1}{c}{\textbf{Output}}
		& \multicolumn{1}{c}{\textbf{Description}} \\

		\tabucline[0.5pt]{1-4}

			provision
		& Endpoint Reference, Service Package
		& Endpoint Reference
		& Tells the provisioning engine to provision the given service package\\

			deprovision
		& Endpoint Reference, Service Package
		& -
		& Tells the provisioning engine to deprovision the given service package\\

	\end{tabu}
	\caption{Interfaces to be implemented by call provisioning engine plugins}
	\label{table:provisioningengine_plugins}
\endgroup

In parallel to this diploma thesis, another diploma thesis is being written about the provisioning manager, which will also use plugins to call provisioning engines~\autocite{nedim}.
Since these plugins offer identical functionality, it makes sense to use the same plugins for both the bootware, as well as the provisioning manager.
In the future, these plugins can be made available via a plugin repository, as described in \autoref{design:pluginrepository}, which will facilitate plugin sharing between the bootware and the provisioning manager.
The call provisioning manager plugins are described in more detail in \autocite{nedim}, since they are only a small part of the bootware and are mainly used in the provisioning manager.
We will use the implementation provided by \autocite{nedim}.

\subsection{Event Plugins}

Unlike the other plugin types, the event plugins don't have any more operations to implement then the initialize and shutdown operations described in \autoref{table:all_plugins}.
Instead, they implement their specific functionality by defining one or more event handlers which will react to specific events when these are published at the event bus.
How exactly these event handlers work will be discussed later.
